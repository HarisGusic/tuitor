#!/usr/bin/env sh

__VERSION='0.0.0'

# Configuration
# TODO account for different PREFIX path
__SYSTEM_CONFIG='/usr/share/tuterm/config.sh'
[ -f "$__SYSTEM_CONFIG" ] && . "$__SYSTEM_CONFIG"

# ┏━━━━━━━━━━━━━━━┓
# ┃ PARSE OPTIONS ┃
# ┗━━━━━━━━━━━━━━━┛

options=$(getopt -o 'hf' --long 'help,fast' -n 'tuterm' -- "$@")
[ $? != 0 ] && exit

usage() {
    echo 'usage: tuterm [-h] [-f] [COMMAND] FILE'
    echo '\ncommands:'
    echo '  tut                 \trun an interactive tutorial (default)'
    echo '  demo                \tplay out all commands without user interaction'
    echo '\npositional arguments:'
    echo '  FILE                \tsource file for the tutorial'
    echo '\noptions:'
    echo '  -h, --help          \tshow this help message and exit'
    echo '  -f, --fast          \tdo not type characters in real time'
}

__OPT_FAST=''
__FILE_ARGUMENT=''

for opt in $options
do
    case "$opt" in
        '-h'|'--help')
            usage
            exit
            ;;
        '-v'|'--version')
            echo "$__VERSION"
            exit
            ;;
        '-f'|'--fast')
            __OPT_FAST='true'
            shift
            continue
            ;;
        '--')
            continue
            ;;
        *)
            # There are multiple file arguments -- error
            [ -n "$__FILE_ARGUMENT" ] && {\
                echo 'tuterm: only one file argument is allowed' >&2
                exit 1
            }
            __FILE_ARGUMENT="$(eval echo $opt)"
            shift
            ;;
    esac
done

# Helper function: convert path to its canonical version
abspath() {
    echo "$(
        [ -f "$1" ] && {
            cd "$(dirname "$1")" || return
            echo "$PWD/$(basename "$1")"
        } || {
            cd "$1" || return
            pwd
        }
    )"
}

# Print $* as if the user were typing it on a keyboard (using DELAY* variables)
print_out() {
    if [ -n "$__OPT_FAST" ]; then
        echo -n "$@"
    else                                # Print char by char in real time
        start_color_code=''
        for i in $(seq 1 ${#*}); do     # For each character in $*
            char="$(echo -n "$*" | cut -zc $i)"
            # Wait a certain delay (as if a user were typing it)
            if echo "$char" | grep -q "[a-zA-Z0-9]" || [ "$char" = "$prev_char" ]
            then
                sleep $DELAY
            else
                # Separator characters take a different time to print
                sleep $DELAY_SEP
            fi
            echo -n "$char"
            # If character with code \033 is encountered, everything until m is
            # considered part of a color code sequence. These characters are
            # printed instantaneously.
            if [ "$char" = "$(echo "\033")" ]; then
                start_color_code='true'
                continue
            elif [ -n "$start_color_code" ] && [ "$char" = 'm' ]; then
                start_color_code=''
                continue
            fi
            [ -n "$start_color_code" ] && continue
            prev_char="$char"   # Repeating characters will be printed using DELAY even if they are separators
        done
        sleep $DELAY
    fi
}

cmdline() {
    prompt
    # Wait a small delay after prompt before typing
    [ -z "$__OPT_FAST" ] && sleep $DELAY_PROMPT
    # Print the command line as if the user were typing it
    print_out "$*"
    echo
    # Run the command that was entered into the command line
    "$@"
}
alias c=cmdline

. "$(realpath "$__FILE_ARGUMENT")"

# Run configuration defined in the tutorial file
configure
[ -z "$DELAY_SEP" ] && DELAY_SEP="$DELAY"
[ -z "$DELAY_PROMPT" ] && DELAY_PROMPT="$DELAY"

tutorial

# vim: ft=sh fdm=marker

#!/usr/bin/env bash

PREFIX='/usr/local'
__VERSION='0.0.0'

# Load system and user configuration
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

__SYSTEM_CONFIG="$PREFIX/share/tuterm/config.sh"
[ -f "$__SYSTEM_CONFIG" ] && . "$__SYSTEM_CONFIG" && configure

if [ -z "$TUTERM_CONFIG" ]; then
    if [ -n "$XDG_CONFIG_HOME" ]; then
        TUTERM_CONFIG="$XDG_CONFIG_HOME/tuterm/config.sh"
    else
        TUTERM_CONFIG="$HOME/.config/tuterm/config.sh"
    fi
fi
[ -f "$TUTERM_CONFIG" ] && . "$TUTERM_CONFIG" && configure

# Shell configuration
shopt -s expand_aliases

# ┏━━━━━━━━━━━━━━━┓
# ┃ PARSE OPTIONS ┃
# ┗━━━━━━━━━━━━━━━┛

options=$(getopt -o 'hvpfsclm:' --long 'help,version,path,fast,server,client,list,mode:' -n 'tuterm' -- "$@")
[ $? != 0 ] && exit

usage() {
    echo -e 'usage: tuterm [-h] [-f] [COMMAND] FILE'
    echo -e '\npositional arguments:'
    echo -e '  FILE                 \tsource file for the tutorial'
    echo -e '\noptions:'
    echo -e '  -h, --help           \tshow this help message and exit'
    echo -e '  -v, --version        \tprint tuterm version'
    echo -e '  -m, --mode MODE      \tselect MODE: tutorial (default) or demo'
    echo -e '  -f, --fast           \tdo not type characters in real time'
    echo -e '  -s, --server         \tonly show instructions in this shell'
    echo -e '  -c, --client         \tprovide user interaction for tutorial'
    echo -e '  -l, --list           \tlist installed tuterm scripts'
    # echo -e '  -L, --list-running   \tlist running tuterm servers'
}

__OPT_FAST=''
__OPT_SERVER=''
__OPT_CLIENT=''
__OPT_MODE='tutorial'
__ARG_FILE=''

for opt in $options
do
    [ "$1" = "$(eval echo $opt)" ] && shift || continue
    case "$opt" in
        '-h'|'--help')
            usage
            exit ;;
        '-v'|'--version')
            echo "tuterm version $__VERSION"
            exit ;;
        '-f'|'--fast')
            readonly __OPT_FAST='true'
            continue ;;
        '-s'|'--server')
            readonly __OPT_SERVER='true'
            continue ;;
        '-c'|'--client')
            readonly __OPT_CLIENT='true'
            continue ;;
        '-m'|'--mode')
            readonly __OPT_MODE="$1"
            shift
            continue ;;
        '-l'|'--list')
            command ls -1 /usr/share/tuterm/scripts
            exit ;;
        *)
            # There are multiple file arguments -- error
            if [ -n "$__ARG_FILE" ]; then
                echo 'tuterm: only one file argument is allowed' >&2
                exit 1
            fi
            __ARG_FILE="$(eval echo $opt)"
            ;;
    esac
done


# ┏━━━━━━━━━━━━━━━━━━┓
# ┃ Helper functions ┃
# ┗━━━━━━━━━━━━━━━━━━┛

# Print $* as if the user were typing it on a keyboard (using DELAY* variables)
# --fast option makes the output instantaneous
__print_out() {
    if option 'fast'; then                  # Print it out instantaneously
        echo -n "$@"
    else                                    # Print char by char in real time
        local start_color_code=''
        for i in $(seq 1 "$(echo "$*" | wc -m)")    # For each character in $*
        do
            local char="$(echo -n "$*" | cut -c $i | tr -d '\n')"
            # Wait a certain delay (as if a user were typing it)
            if echo "$char" | grep -q "[a-zA-Z0-9]" || [ "$char" = "$__prev_char" ]
            then
                sleep $DELAY
            else
                # Separator characters take a different time to print
                sleep $DELAY_SEP
            fi
            echo -n "$char"
            # If character with code \033 is encountered, everything until m is
            # considered part of a color code sequence. These characters are
            # printed instantaneously.
            if [ "$char" = "$(echo "\033")" ]; then
                start_color_code='true'
                continue
            elif [ -n "$start_color_code" ] && [ "$char" = 'm' ]; then
                start_color_code=''
                continue
            fi
            [ -n "$start_color_code" ] && continue
            # Repeating characters will be printed using DELAY even if they are separators
            __prev_char="$char"
        done
        sleep $DELAY
    fi
}

# ┏━━━━━━━━━━━━━━━┓
# ┃ API FUNCTIONS ┃
# ┗━━━━━━━━━━━━━━━┛

# Convert path to its canonical version (TODO hide this function from the API?)
abspath() {
    echo "$(
        [ -f "$1" ] && {                                    # File exists
            pushd "$(dirname "$1")" >/dev/null || return    # cd and print path
            echo "$PWD/$(basename "$1")"
            popd >/dev/null
        } || {
            pushd "$1" >/dev/null 2>/dev/null || return
            pwd
            popd >/dev/null
        }
    )"
}

# Set color for printing. See manpage for details.
color() {
    # Try to query a variable named "COLOR_$1", automatically capitalized
    local color_var="COLOR_${1^^}"
    if [ -v "$color_var" ]; then            # Variable exists
        echo -ne "\033[${!color_var}m"
    else                                    # doesn't
        echo -ne "\033[$1m";
    fi
}

# Test if all options from $@ were provided to tuterm (only long format)
option() {                                          # WARNING: bashisms ahead
    for arg in "$@"; do
        local opt_name="__OPT_${arg^^}"
        [ -z "${!opt_name}" ] && return 1
    done
    return 0
}
alias opt=option

# Test if $1 is the active mode
mode() { [[ "$__OPT_MODE" = "$1"* ]]; }

cmdline() {
    prompt
    if ! option 'client'; then
        stty -echo
        option 'fast' || sleep $DELAY_PROMPT  # Wait a small delay after prompt
        ! mode 'demo' && color cmdline
        __print_out "$*"; color 0 # Type out the command line
        echo
        stty echo
    fi
    if mode 'tutorial'; then
        __USER_INPUT=''
        if option 'server'; then                        # --server
            read __discard < "/tmp/tuterm_client_$$"    # Wait for continue signal
        else                                            # not --server
            if ! option 'client'; then prompt; fi
            read __USER_INPUT                           # Read user input
            if [ "$__USER_INPUT" != "$*" ]; then        # Oops, wrong input
                {
                    color warning
                    echo -e "Wrong command, try again"
                    color 0
                } >&2
                __OPT_FAST='true' cmdline "$@"
                return
            fi
            # Send continue signal to server
            if option 'client'; then
                echo CONTINUE > "/tmp/tuterm_client_$__ARG_PID"
            fi
        fi
    fi
    # Run the command that was entered into the command line
    if ! option 'server'; then "$@"; fi
}
alias c=cmdline

# Message that works in both tutorial and demo mode
Message() {
    if option 'client'; then return 0; fi
    color message
    echo "$*"
    color 0
}
alias M=Message

# Message that works only in tutorial mode
message() {
    ! mode 'demo' && Message "$@"
}
alias m=message

# ┏━━━━━━━━━━━━━━━━━━━━━┓
# ┃ ARGUMENT PROCESSING ┃
# ┗━━━━━━━━━━━━━━━━━━━━━┛

# File that doesn't contain / will be taken from the default path
if [[ "$__ARG_FILE" != */* ]]; then
    # TODO add user-specific scripts directory
    __file="/usr/share/tuterm/scripts/$__ARG_FILE"
    # If default path contains the file take it, otherwise take the local file
    [ -f "$__file" ]  && __ARG_FILE="$__file"
fi
__ARG_FILE="$(abspath "$__ARG_FILE")"

if ! option 'client' && [ ! -f "$__ARG_FILE" ]; then
    echo 'tuterm: tutorial file does not exist' >&2
    exit 1
fi

# Create a backup of the tutorial script in shm
if mode 'tutorial' && option 'server'; then             # --tutorial --server
    cat "$__ARG_FILE" > "/dev/shm/tuterm_server_$$"
fi

if mode 'tutorial' && option 'client'; then             # --tutorial --client
    # If no server pid is specified, try to detect it (TODO multiple servers?)
    [ -z "$__ARG_PID" ] &&
        __ARG_PID="$(ls /tmp/tuterm_server_* 2>/dev/null | head -1)"
    __ARG_PID="${__ARG_PID##/tmp/tuterm_server_}"
    # The client does not take a file argument, it will use the file
    # /dev/shm/tuterm_server_* created by the server
    __ARG_FILE="/dev/shm/tuterm_server_$__ARG_PID"
    # Exit if the pid is invalid
    if ! kill -0 "$__ARG_PID" 2>/dev/null || [ ! -p "/tmp/tuterm_server_$__ARG_PID" ]
    then
        echo 'tuterm: invalid server PID' >&2; exit 1
    fi
else
    [ -z "$__ARG_FILE" ] && { echo 'tuterm: no file specified' >&2; exit 1; }
fi

# Make argument variables read-only
readonly __ARG_FILE __ARG_PID

# ┏━━━━━━━━━━━━┓
# ┃ RUN SCRIPT ┃
# ┗━━━━━━━━━━━━┛

if mode 'demo' || option 'server'; then
    # Disable user input in the terminal
    # TODO actually, this just makes it invisible. stty -cread doesn't work,
    # must look into that
    stty -echo
fi

# --tutorial --server
mode 'tutorial' && option 'server' && {
    # Create a FIFO to communicate with client shell
    mkfifo "/tmp/tuterm_server_$$" "/tmp/tuterm_client_$$"
}

# Exit cleanup
__on_exit() {
    # Remove inter-process files
    mode 'tutorial' && option 'server' && {
        rm -f "/dev/shm/tuterm_server_$$"
        rm -f "/tmp/tuterm_server_$$" "/tmp/tuterm_client_$$"
    }
}
trap __on_exit EXIT

readonly TUTORIAL_FILE="$__ARG_FILE"
. "$(realpath "$__ARG_FILE")"   # Load tutorial script

# Run configuration defined in the tutorial file
configure "$__ARG_CMD"
[ -z "$DELAY_SEP" ]     && DELAY_SEP="$DELAY"
[ -z "$DELAY_PROMPT" ]  && DELAY_PROMPT="$DELAY"

setup                           # Perform any additional setup for the tutorial
clear
run

# vim: filetype=sh foldmethod=syntax

#!/usr/bin/env bash

__VERSION='0.0.0'

# Configuration
# TODO account for different PREFIX path
__SYSTEM_CONFIG='/usr/share/tuterm/config.sh'
[ -f "$__SYSTEM_CONFIG" ] && . "$__SYSTEM_CONFIG"

shopt -s expand_aliases

# ┏━━━━━━━━━━━━━━━┓
# ┃ PARSE OPTIONS ┃
# ┗━━━━━━━━━━━━━━━┛

options=$(getopt -o 'hf' --long 'help,fast' -n 'tuterm' -- "$@")
[ $? != 0 ] && exit

usage() {
    echo 'usage: tuterm [-h] [-f] [COMMAND] FILE'
    echo '\ncommands:'
    echo '  tut                 \trun an interactive tutorial (default)'
    echo '  demo                \tplay out all commands without user interaction'
    echo '\npositional arguments:'
    echo '  FILE                \tsource file for the tutorial'
    echo '\noptions:'
    echo '  -h, --help          \tshow this help message and exit'
    echo '  -f, --fast          \tdo not type characters in real time'
}

__OPT_FAST=''
__ARG_FILE=''
__ARG_CMD=''

for opt in $options
do
    [ "$1" = "$opt" ] && shift
    case "$opt" in
        '-h'|'--help')
            usage
            exit
            ;;
        '-v'|'--version')
            echo "$__VERSION"
            exit
            ;;
        '-f'|'--fast')
            __OPT_FAST='true'
            continue
            ;;
        '--')
            continue
            ;;
        *)
            if [ -z "$__ARG_CMD" ]; then
                __ARG_CMD="$(eval echo $opt)"
                continue
            fi
            # There are multiple file arguments -- error
            [ -n "$__ARG_FILE" ] && {\
                echo 'tuterm: only one file argument is allowed' >&2
                exit 1
            }
            __ARG_FILE="$(eval echo $opt)"
            ;;
    esac
done

# If only one positional argument was provided, treat it as a file and run the
# default command (tut)
if [ -z "$__ARG_FILE" ]; then
    __ARG_FILE="$__ARG_CMD"
    __ARG_CMD='tut'
fi

# File invalid
[ -z "$__ARG_FILE" ] && { echo 'tuterm: no file specified' >&2; exit 1; }

# Helper function: convert path to its canonical version
abspath() {
    echo "$(
        [ -f "$1" ] && {
            cd "$(dirname "$1")" || return
            echo "$PWD/$(basename "$1")"
        } || {
            cd "$1" || return
            pwd
        }
    )"
}

# Print $* as if the user were typing it on a keyboard (using DELAY* variables)
# --fast option makes the output instantaneous
print_out() {
    if [ -n "$__OPT_FAST" ]; then
        echo -n "$@"
    else                                    # Print char by char in real time
        start_color_code=''
        for i in $(seq 1 "$(echo "$*" | wc -m)")    # For each character in $*
        do
            char="$(echo -n "$*" | cut -c $i | tr -d '\n')"
            # Wait a certain delay (as if a user were typing it)
            if echo "$char" | grep -q "[a-zA-Z0-9]" || [ "$char" = "$prev_char" ]
            then
                sleep $DELAY
            else
                # Separator characters take a different time to print
                sleep $DELAY_SEP
            fi
            echo -n "$char"
            # If character with code \033 is encountered, everything until m is
            # considered part of a color code sequence. These characters are
            # printed instantaneously.
            if [ "$char" = "$(echo "\033")" ]; then
                start_color_code='true'
                continue
            elif [ -n "$start_color_code" ] && [ "$char" = 'm' ]; then
                start_color_code=''
                continue
            fi
            [ -n "$start_color_code" ] && continue
            prev_char="$char"   # Repeating characters will be printed using DELAY even if they are separators
        done
        sleep $DELAY
    fi
}

cmdline() {
    prompt
    # Wait a small delay after prompt before typing
    [ -z "$__OPT_FAST" ] && sleep $DELAY_PROMPT
    # Print the command line as if the user were typing it
    echo -ne "\033[1;33m"
    print_out "$*"
    echo -ne "\033[0m"
    echo
    if [ "$__ARG_CMD" = 'tut' ]; then
        __USER_INPUT=''
        while true; do
            prompt
            # TODO how to discard stdin contents before now
            read __USER_INPUT
            [ "$__USER_INPUT" == "$*" ] && break
            echo -e "\033[1;32mWrong command, try again\033[0m" >&2
        done
    fi
    # Run the command that was entered into the command line
    "$@"
}
alias c=cmdline

. "$(realpath "$__ARG_FILE")"

# Run configuration defined in the tutorial file
configure
[ -z "$DELAY_SEP" ] && DELAY_SEP="$DELAY"
[ -z "$DELAY_PROMPT" ] && DELAY_PROMPT="$DELAY"

tutorial

# vim: ft=sh fdm=marker
